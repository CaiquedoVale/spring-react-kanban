# Nome da sua aplicação Spring
spring.application.name=backend


# =======================================================
# CONFIGURAÇÃO DO BANCO DE DADOS (DataSource)
# Como o Spring se conecta ao seu banco MySQL.
# =======================================================

# A "Coordenada GPS" do banco de dados.
# jdbc:mysql:// -> O "protocolo" para falar com MySQL.
# localhost:3306 -> O "endereço" (máquina local, porta 3306).
# /db_kanban -> O "schema" (o banco de dados) específico que queremos usar.
spring.datasource.url=jdbc:mysql://localhost:3306/db_kanban

# O "login" para acessar o banco de dados.
spring.datasource.username=root
# A "senha" para acessar o banco de dados.
spring.datasource.password=root


# =======================================================
# CONFIGURAÇÃO DO JPA (Hibernate)
# Como o "Tradutor" (JPA/Hibernate) deve se comportar.
# =======================================================

# O "Dialeto" específico. Diz ao Hibernate exatamente qual
# "sotaque" do SQL o MySQL fala (ex: como escrever 'auto-incremento').
spring.jpa.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# A "Regra de Construção" automática (Data Definition Language).
# 'update': Diz ao Hibernate: "Olhe minhas classes @Entity (Usuario, Quadro).
# Se as tabelas não existirem no banco, CRIE-AS. Se elas existirem, mas
# estiverem diferentes (ex: falta uma coluna), ALTERE-AS."
# (É ótimo para desenvolvimento, mas NUNCA usado em produção).
spring.jpa.hibernate.ddl-auto=update

# "Hibernate, por favor, imprima no console todo SQL que você
# executar." (Foi isso que nos mostrou o "Hibernate: select..."
# e nos ajudou a matar o "fantasma 403"!).
spring.jpa.show-sql=true

# "Quando você imprimir o SQL, formate-o de forma legível
# (com quebras de linha e indentação)."
spring.jpa.properties.hibernate.format_sql=true


# =======================================================
# CONFIGURAÇÃO DE SEGURANÇA (Personalizada)
# Valores que NÓS criamos para a NOSSA aplicação.
# =======================================================

# O "Selo Real Secreto" do nosso "Mestre dos Passaportes" (TokenService).
# O Spring NÃO usa isso. O nosso TokenService "lê" este valor
# usando a anotação @Value("${api.security.token.secret}").
# É a chave usada para assinar e validar todos os nossos Tokens JWT.
api.security.token.secret=NCo6UDIqeVg5JChLIyZBISE=